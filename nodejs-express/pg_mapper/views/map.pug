extends layout
block content

    #map
    script.
        //Array that will save all the layers
        var layerArray = [];
        
        
        
        var map = L.map('map',{preferCanvas: true,renderer: L.canvas({}), center: [39.96964,116.33251], zoom: 10});
        map.createPane('lensPane');
        map.createPane('velPane');
        map.createPane('attLensPane');
        map.getPane('lensPane').style.zIndex = 480;
        map.getPane('attLensPane').style.zIndex = 410;
        map.getPane('velPane').style.zIndex = 400;
        var popup = L.popup();
        var popup2 = L.popup();

        var minValueVel;
        var maxValueVel;
        var minValueLength;
        var maxValueLength;
        var minValueTime;
        var maxValueTime;
        var minValueTimeDuration;
        var maxValueTimeDuration;

        //create array with all layers?

        var markerGroup  = L.featureGroup().addTo(map);
        var markerGroup1 = L.featureGroup().addTo(map);
        var markerGroup2 = L.featureGroup().addTo(map);
        var markerGroup3 = L.featureGroup().addTo(map);
        
        var attLenResults = L.featureGroup({pane: 'attLensPane'}).addTo(map);

        var lensesLayer = L.featureGroup({pane: 'lensPane'}).addTo(map);

        var lensPreCreationLayer = L.layerGroup().addTo(map);
        
        var lastMarkerGroupID = null ;
        var lastMarkerGroupID1 = null ;
        var lastMarkerGroupID2 = null ;
        var lastMarkerGroupID3 = null ;
        var defaultLayerFlag = true;

        var createQueryLensesFlag = false;
        var createAttributeLensesFlag = false;

        var attributeFuncVar = "length";
        var encodingFuncVar = "color";

        var attLensesArray = [];


        //black and white, when it is a greyish color its hard to see
        /*L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}{r}.{ext}', {
            attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            subdomains: 'abcd',
            minZoom: 2,
            maxZoom: 25,
            ext: 'png'
        }).addTo(map);*/

        //Terrain is coloured, colors sometimes hard to see
       /* L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}{r}.{ext}', {
            attribution: 'Map tiles by <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            subdomains: 'abcd',
            minZoom: 0,
            maxZoom: 18,
            ext: 'png'
        }).addTo(map);*/

        //ALL black and dark grey
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
            subdomains: 'abcd',
            maxZoom: 19
        }).addTo(map);

        //var myData = jsonData;
        var myData = !{JSON.stringify(jsonData)};

        // Create variable to hold map element, give initial settings to map
        var customControlQ =  L.Control.extend({

        options: {
            position: 'topleft'
        },

        onAdd: function (map) {
            var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');

            container.style.backgroundColor = 'white';     
            container.style.backgroundImage = "url(images/636051.svg)";
            container.style.backgroundSize = "30px 30px";
            container.style.width = '30px';
            container.style.height = '30px';

            container.onclick = function(e){
                L.DomEvent.stopPropagation(e); 
                if(!createAttributeLensesFlag){
                    createQueryLensesFlag = !createQueryLensesFlag;
                    if (createQueryLensesFlag){
                        container.style.backgroundColor = 'grey';
                    }
                    else{
                        container.style.backgroundColor = 'white';   
                    }
                }
            }

            return container;
        }
        });
        var customControlA =  L.Control.extend({

        options: {
            position: 'topleft'
        },

        onAdd: function (map) {
            var container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');

            container.style.backgroundColor = 'white';     
            //container.style.backgroundImage = "url(images/636051.svg)";
            container.style.backgroundSize = "30px 30px";
            container.style.width = '30px';
            container.style.height = '30px';

            container.onclick = function(e){
                L.DomEvent.stopPropagation(e); 
                if(!createQueryLensesFlag){
                    createAttributeLensesFlag = !createAttributeLensesFlag;
                    if (createAttributeLensesFlag){
                        container.style.backgroundColor = 'grey';
                    }
                    else{
                        container.style.backgroundColor = 'white';   
                    }
                }
            }

            return container;
        }
        });

        map.addControl(new customControlQ());
        map.addControl(new customControlA());
            
        var container = document.getElementsByClassName("leaflet-zoom-animated");
        container[0].onclick = function(e){
                L.DomEvent.stopPropagation(e);
        }
                

        
        //var defaultLayer = new L.GeoJSON().addTo(map);
        var firstStyle = {
            "color": '#FF6347',
            "weight": 1.5
            
        };
        /*var color2;
            var r = Math.min(Math.max(Math.floor(Math.random() * 255), 55), 200);
            var g = Math.min(Math.max(Math.floor(Math.random() * 255), 75), 255);
            var b = Math.min(Math.max(Math.floor(Math.random() * 255), 100), 225);
            color2= "rgb("+r+" ,"+g+","+ b+")"; 

            

            var individualStyle = {
                "color": color2,
                "weight": 2,
                "opacity": 0.5
            };*/

     
        // Add JSON to map
        
        var defaultLayer = new L.geoJson(myData,firstStyle).addTo(map);
    
        map.on('zoomend', function() {
            console.log(map.getZoom())
            if (map.getZoom() >= 19){
                    map.addLayer(markerGroup3);
            }
            else {
                if (map.hasLayer(markerGroup3)) {
                    map.removeLayer(markerGroup3);
                } else {
                    console.log("MarkerGroup3 not active");
                }
                if (map.getZoom() >= 17){
                    map.addLayer(markerGroup2);
                }
                else {
                    if (map.hasLayer(markerGroup2)) {
                        map.removeLayer(markerGroup2);
                    } else {
                        console.log("MarkerGroup2 not active");
                    }
                    if (map.getZoom() >= 15){
                        map.addLayer(markerGroup1);
                    }
                    else {
                        if (map.hasLayer(markerGroup1)) {
                            map.removeLayer(markerGroup1);
                        } else {
                            console.log("MarkerGroup1 not active");
                        }
                
                    }
                }
            }
            lensesLayer.bringToFront();
        });   
            

        function onMapClick(e) {// + "<input id='radiusBox' type='text' size='20'/>"
            if(createQueryLensesFlag){   
                queryLensMenu(e);
            }
            else if(createAttributeLensesFlag){
                attributeLensMenu(e);
            }
        }

        map.on('click', onMapClick);

       

        function createQuery(lng, lat, radiusQuery, typeLens, minVal, maxVal){
            lensPreCreationLayer.clearLayers();
            console.log("Im removing the map now and adding new ones afterwards")
            if(defaultLayerFlag){
                defaultLayerFlag = false;
                map.removeLayer(defaultLayer);
            }

            if(lastMarkerGroupID !=null){
                markerGroup.removeLayer(lastMarkerGroupID);
                lastMarkerGroupID = null;
            }
            if(lastMarkerGroupID1 !=null){
                markerGroup1.removeLayer(lastMarkerGroupID1);
                lastMarkerGroupID1 = null;
            }
            if(lastMarkerGroupID2 !=null){
                markerGroup2.removeLayer(lastMarkerGroupID2);
                lastMarkerGroupID2 = null;
            }
            if(lastMarkerGroupID3 !=null){
                markerGroup3.removeLayer(lastMarkerGroupID3);
                lastMarkerGroupID3 = null;
            }

                // Create URL
            var urlString3 = "query/trajectory_lines/"  + lng + "/" + lat + "/" + radiusQuery + "/" + typeLens + "/" + minVal + "/" + maxVal;
            var urlString2 = "query/trajectory_lines1/" + lng + "/" + lat + "/" + radiusQuery + "/" + typeLens + "/" + minVal + "/" + maxVal;
            var urlString1 = "query/trajectory_lines2/" + lng + "/" + lat + "/" + radiusQuery + "/" + typeLens + "/" + minVal + "/" + maxVal;
            var urlString  = "query/trajectory_lines3/" + lng + "/" + lat + "/" + radiusQuery + "/" + typeLens + "/" + minVal + "/" + maxVal;
            
            var lensesVar = createLens(lng, lat, radiusQuery, typeLens, minVal, maxVal);
            
            var newData = $.ajax({
                url: urlString,
                type: 'GET',
                dataType:'json',
                success: console.log("Data successfully loaded!"),
                error: function (xhr) {
                    alert(xhr.statusText)
                }
                
            }) 
            $.when(newData).done(function() {
                
                if(newData.responseJSON.features != null){
                    var tracksToDraw = L.geoJson(newData.responseJSON,firstStyle);
                    tracksToDraw.addTo(markerGroup);
                    lastMarkerGroupID = tracksToDraw._leaflet_id;
                    lensesVar.colorSuccess();
                }
                lensesLayer.bringToFront();
            }); 
            var newData1 = $.ajax({
                url: urlString1,
                type: 'GET',
                dataType:'json',
                success: console.log("Data successfully loaded!"),
                error: function (xhr) {
                    alert(xhr.statusText)
                }
                
            }) 
            $.when(newData1).done(function() {
                if(newData1.responseJSON.features != null){
                    var tracksToDraw = L.geoJson(newData1.responseJSON,firstStyle);
                    tracksToDraw.addTo(markerGroup1);
                    lastMarkerGroupID1 = tracksToDraw._leaflet_id;
                    lensesVar.colorSuccess();
                }
                lensesLayer.bringToFront();
            });
            var newData2 = $.ajax({
                url: urlString2,
                type: 'GET',
                dataType:'json',
                success: console.log("Data successfully loaded!"),
                error: function (xhr) {
                    alert(xhr.statusText)
                }
                
            }) 
            $.when(newData2).done(function() {
                if(newData2.responseJSON.features != null){
                    var tracksToDraw = L.geoJson(newData2.responseJSON,firstStyle);
                    tracksToDraw.addTo(markerGroup2);
                    lastMarkerGroupID2 = tracksToDraw._leaflet_id;
                    lensesVar.colorSuccess();
                }
                lensesLayer.bringToFront();
            });
            var newData3 = $.ajax({
                url: urlString3,
                type: 'GET',
                dataType:'json',
                success: console.log("Data successfully loaded!"),
                error: function (xhr) {
                    alert(xhr.statusText)
                }
                
            }) 
            $.when(newData3).done(function() {
                if(newData3.responseJSON.features != null){
                    var tracksToDraw = L.geoJson(newData3.responseJSON,firstStyle);
                    tracksToDraw.addTo(markerGroup3);
                    lastMarkerGroupID3 = tracksToDraw._leaflet_id;
                    lensesVar.colorSuccess();
                }
                lensesLayer.bringToFront();
            });
            
            attLensesArray.forEach(function(item, index, array) {
                item.updateALL();
            });
        }
        
        /*function createAttributeQuery(lngLat, radiusQuery, aTypeLens, encoding){
            var attLayer = L.featureGroup().addTo(attLenResults);
            var _attLayer = L.featureGroup().addTo(attLayer);
            var _attLayer1 = L.featureGroup().addTo(attLayer);
            var _attLayer2 = L.featureGroup().addTo(attLayer);
            var _attLayer3 = L.featureGroup().addTo(attLayer);
            
                // Create URL
            var urlString3 = "attQuery/trajectory_lines/"  + lngLat.lng + "/" + lngLat.lat + "/" + radiusQuery;
            var urlString2 = "attQuery/trajectory_lines1/" + lngLat.lng + "/" + lngLat.lat + "/" + radiusQuery;
            var urlString1 = "attQuery/trajectory_lines2/" + lngLat.lng + "/" + lngLat.lat + "/" + radiusQuery;
            var urlString  = "attQuery/trajectory_lines3/" + lngLat.lng + "/" + lngLat.lat + "/" + radiusQuery;
            
            var lensesVar = createALens(lngLat, radiusQuery, aTypeLens, encoding);
            lensesVar.lID = attLayer._leaflet_id;
            var newData = $.ajax({
                url: urlString,
                type: 'GET',
                dataType:'json',
                success: console.log("Data successfully loaded!"),
                error: function (xhr) {
                    alert(xhr.statusText)
                }
                
            }) 
            $.when(newData).done(function() {
                
                if(newData.responseJSON.features != null){
                    console.log(newData.responseJSON.features);
                    newData.responseJSON.features.forEach(function(item, index, array) {
                        var tracksToDraw = L.geoJson(item,firstStyle);
                        switch(aTypeLens) {
                            case "length":
                                lengthAtt(tracksToDraw, item.properties, encoding);
                                break;
                            case "duration":
                                // code block
                                durationAtt(tracksToDraw, item.properties, encoding);
                                break;
                            case "vel":
                                velocityAtt(tracksToDraw, item.properties, encoding);
                                break;
                            case "time":
                                timeAtt(tracksToDraw, item.properties, encoding);
                                break;
                        } 
                        lensesVar.intersections.forEach(function(lensInt, index, array) {
                            if(lensInt.areaQuery.getBounds().intersects(tracksToDraw.getBounds())){
                                console.log("This layer intersects the other lenses");
                                console.log(lensInt.areaQuery.getBounds().intersects(tracksToDraw.getBounds()));
                                console.log(lensInt);
                                console.log(tracksToDraw);
                                lensInt.updateLayer(tracksToDraw,item.properties)
                            }
                        });
                        tracksToDraw.addTo(_attLayer);
                    });
                    
                }
            }); 
            var newData1 = $.ajax({
                url: urlString1,
                type: 'GET',
                dataType:'json',
                success: console.log("Data successfully loaded!"),
                error: function (xhr) {
                    alert(xhr.statusText)
                }
                
            }) 
            $.when(newData1).done(function() {
                if(newData1.responseJSON.features != null){
                    console.log(newData1.responseJSON.features);
                    newData1.responseJSON.features.forEach(function(item, index, array) {
                        var tracksToDraw = L.geoJson(item,firstStyle);
                        switch(aTypeLens) {
                            case "length":
                                lengthAtt(tracksToDraw, item.properties, encoding);
                                break;
                            case "duration":
                                // code block
                                durationAtt(tracksToDraw, item.properties, encoding);
                                break;
                            case "vel":
                                velocityAtt(tracksToDraw, item.properties, encoding);
                                break;
                            case "time":
                                timeAtt(tracksToDraw, item.properties, encoding);
                                break;
                        } 
                        lensesVar.intersections.forEach(function(lensInt, index, array) {
                            console.log(lensInt, index);
                            if(lensInt.areaQuery.getBounds().intersects(tracksToDraw.getBounds())){
                                lensInt.updateLayer(tracksToDraw,item.properties)
                            }
                        });
                        tracksToDraw.addTo(_attLayer1);
                    });
                    
                }
            });
            var newData2 = $.ajax({
                url: urlString2,
                type: 'GET',
                dataType:'json',
                success: console.log("Data successfully loaded!"),
                error: function (xhr) {
                    alert(xhr.statusText)
                }
                
            }) 
            $.when(newData2).done(function() {
                if(newData2.responseJSON.features != null){
                    console.log(newData2.responseJSON.features);
                    newData2.responseJSON.features.forEach(function(item, index, array) {
                        var tracksToDraw = L.geoJson(item,firstStyle);
                        switch(aTypeLens) {
                            case "length":
                                lengthAtt(tracksToDraw, item.properties, encoding);
                                break;
                            case "duration":
                                // code block
                                durationAtt(tracksToDraw, item.properties, encoding);
                                break;
                            case "vel":
                                velocityAtt(tracksToDraw, item.properties, encoding);
                                break;
                            case "time":
                                timeAtt(tracksToDraw, item.properties, encoding);
                                break;
                        } 
                        lensesVar.intersections.forEach(function(lensInt, index, array) {
                            console.log(lensInt, index);
                            if(lensInt.areaQuery.getBounds().intersects(tracksToDraw.getBounds())){
                                lensInt.updateLayer(tracksToDraw,item.properties)
                            }
                        });
                        tracksToDraw.addTo(_attLayer2);
                    });
                    
                }
            });
            var newData3 = $.ajax({
                url: urlString3,
                type: 'GET',
                dataType:'json',
                success: console.log("Data successfully loaded!"),
                error: function (xhr) {
                    alert(xhr.statusText)
                }
                
            }) 
            $.when(newData3).done(function() {
                if(newData3.responseJSON.features != null){
                    console.log(newData3.responseJSON.features);
                    newData3.responseJSON.features.forEach(function(item, index, array) {
                        var tracksToDraw = L.geoJson(item,firstStyle);
                        switch(aTypeLens) {
                            case "length":
                                lengthAtt(tracksToDraw, item.properties, encoding);
                                break;
                            case "duration":
                                // code block
                                durationAtt(tracksToDraw, item.properties, encoding);
                                break;
                            case "vel":
                                velocityAtt(tracksToDraw, item.properties, encoding);
                                break;
                            case "time":
                                timeAtt(tracksToDraw, item.properties, encoding);
                                break;
                        } 
                        lensesVar.intersections.forEach(function(lensInt, index, array) {
                            console.log(lensInt, index);
                            if(lensInt.areaQuery.getBounds().intersects(tracksToDraw.getBounds())){
                                lensInt.updateLayer(tracksToDraw,item.properties)
                            }
                        });
                        tracksToDraw.addTo(_attLayer3);
                    });
                    
                    lensesVar.colorSuccess();
                }
            });
            lensesVar.colorSuccess();
            
        }*/



        /*function attributeLensCreation(lngLat,radius,attribute,encoding){
            var metresPerPixel = 40075016.686 * Math.abs(Math.cos(lngLat.lat * 180/Math.PI)) / Math.pow(2, map.getZoom()+8);
            var pixelsInRadius = radius / metresPerPixel;
            var aLens = createALens(lngLat, radius, attribute, encoding);
            var layerToPaintVEL = L.featureGroup().addTo(attLenResults);

            if(defaultLayerFlag){
                defaultLayer.eachLayer(function (layer) {
                    var yourDistance = L.GeometryUtil.closest(map, layer, lngLat).distance;
                    //var layersActive = layersWithin(map, layer, lngLat, pixelsInRadius)
                    if ( yourDistance <= pixelsInRadius){
                        switch(attribute) {
                            case "length":
                                lengthAtt(layer, encoding);
                                break;
                            case "duration":
                                // code block
                                durationAtt(layer, encoding);
                                break;
                            case "vel":
                                velocityAtt(layerToPaintVEL,layer,encoding);
                                break;
                            case "time":
                                timeAtt(layer, encoding);
                                break;
                        }   
                        
                    //}
                    }
                
                });
            }
            else{
                 if(lastMarkerGroupID !=null ){
                    markerGroup.getLayer(lastMarkerGroupID).eachLayer(function (layer) {
                        var yourDistance = L.GeometryUtil.closest(map, layer, lngLat).distance;
                        //var layersActive = layersWithin(map, layer, lngLat, pixelsInRadius)
                        if ( yourDistance <= pixelsInRadius){
                            switch(attribute) {
                                case "length":
                                    lengthAtt(layer, encoding);
                                    break;
                                case "duration":
                                    // code block
                                    durationAtt(layer, encoding);
                                    break;
                                case "vel":
                                    velocityAtt(layerToPaintVEL,layer,encoding);
                                    break;
                                case "time":
                                    timeAtt(layer, encoding);
                                    break;
                            }   
                            
                        //}
                        }
                        
                    });
                }
                if(lastMarkerGroupID1 !=null && map.hasLayer(markerGroup1)){
                    markerGroup1.getLayer(lastMarkerGroupID1).eachLayer(function (layer) {
                        var yourDistance = L.GeometryUtil.closest(map, layer, lngLat).distance;
                        //var layersActive = layersWithin(map, layer, lngLat, pixelsInRadius)
                        if ( yourDistance <= pixelsInRadius){
                            switch(attribute) {
                                case "length":
                                    lengthAtt(layer, encoding);
                                    break;
                                case "duration":
                                    // code block
                                    durationAtt(layer, encoding);
                                    break;
                                case "vel":
                                    velocityAtt(layerToPaintVEL,layer,encoding);
                                    break;
                                case "time":
                                    timeAtt(layer, encoding);
                                    break;
                            }   
                            
                        //}
                        }
                    
                    });          
                }
                if(lastMarkerGroupID2 !=null && map.hasLayer(markerGroup2)){
                    markerGroup2.getLayer(lastMarkerGroupID2).eachLayer(function (layer) {
                        var yourDistance = L.GeometryUtil.closest(map, layer, lngLat).distance;
                        //var layersActive = layersWithin(map, layer, lngLat, pixelsInRadius)
                        if ( yourDistance <= pixelsInRadius){
                            switch(attribute) {
                                case "length":
                                    lengthAtt(layer, encoding);
                                    break;
                                case "duration":
                                    // code block
                                    durationAtt(layer, encoding);
                                    break;
                                case "vel":
                                    velocityAtt(layerToPaintVEL,layer,encoding);
                                    break;
                                case "time":
                                    timeAtt(layer, encoding);
                                    break;
                            }   
                            
                        //}
                        }
                        
                    });   
                }
                if(lastMarkerGroupID3 !=null && map.hasLayer(markerGroup3)){
                    markerGroup3.getLayer(lastMarkerGroupID3).eachLayer(function (layer) {
                        var yourDistance = L.GeometryUtil.closest(map, layer, lngLat).distance;
                        //var layersActive = layersWithin(map, layer, lngLat, pixelsInRadius)
                        if ( yourDistance <= pixelsInRadius){
                            switch(attribute) {
                                case "length":
                                    lengthAtt(layer, encoding);
                                    break;
                                case "duration":
                                    // code block
                                    durationAtt(layer, encoding);
                                    break;
                                case "vel":
                                    velocityAtt(layerToPaintVEL,layer,encoding);
                                    break;
                                case "time":
                                    timeAtt(layer, encoding);
                                    break;
                            }   
                            
                        //}
                        }
                        
                    });
                }
            
            }
            aLens.colorSuccess();
            if(attribute == "vel" && encoding == "color"){
                aLens.lID = layerToPaintVEL._leaflet_id;
            }
            console.log("lensesLayer now");
            lensesLayer.bringToFront();
        }*/

        /////
        /////
        /////

        /////
        /////
        /////

        function deleteQuery(lng, lat, radius, type, minVal, maxVal){
            var urlString3 = "queryRemoval/trajectory_lines/"  + lng + "/" + lat + "/" + radius + "/" + type + "/" + minVal + "/" + maxVal;
            var urlString2 = "queryRemoval/trajectory_lines1/" + lng + "/" + lat + "/" + radius + "/" + type + "/" + minVal + "/" + maxVal;
            var urlString1 = "queryRemoval/trajectory_lines2/" + lng + "/" + lat + "/" + radius + "/" + type + "/" + minVal + "/" + maxVal;
            var urlString  = "queryRemoval/trajectory_lines3/" + lng + "/" + lat + "/" + radius + "/" + type + "/" + minVal + "/" + maxVal;

            var newData = $.ajax({
                url: urlString,
                type: 'GET',
                dataType:'json',
                success: console.log("1 successfully loaded!"),
                error: function (xhr) {
                    alert(xhr.statusText)
                }
                
            })
            $.when(newData).done(function() {
                
                console.log("Im removing the map now and adding new ones afterwards")
                
                if(newData.responseJSON.features != null){
                    var tracksToDraw = L.geoJson(newData.responseJSON,firstStyle);
                    tracksToDraw.addTo(markerGroup);
                    var idTracks = tracksToDraw._leaflet_id;
                    lastMarkerGroupID = tracksToDraw._leaflet_id;
                    
                }
                lensesLayer.bringToFront();
                
            });
            var newData1 = $.ajax({
                url: urlString1,
                type: 'GET',
                dataType:'json',
                success: console.log("2 successfully loaded!"),
                error: function (xhr) {
                    alert(xhr.statusText)
                }
                
            })
            $.when(newData1).done(function() {
                
                console.log("Im removing the map now and adding new ones afterwards")
                
                if(newData1.responseJSON.features != null){
                    var tracksToDraw = L.geoJson(newData1.responseJSON,firstStyle);
                    tracksToDraw.addTo(markerGroup1);
                    lastMarkerGroupID1 = tracksToDraw._leaflet_id;
                    
                }
                lensesLayer.bringToFront();
            });
            var newData2 = $.ajax({
                url: urlString2,
                type: 'GET',
                dataType:'json',
                success: console.log("3 successfully loaded!"),
                error: function (xhr) {
                    alert(xhr.statusText)
                }
                
            })
            $.when(newData2).done(function() {
                
                console.log("Im removing the map now and adding new ones afterwards")
                
                if(newData2.responseJSON.features != null){
                    var tracksToDraw = L.geoJson(newData2.responseJSON,firstStyle);
                    tracksToDraw.addTo(markerGroup2);
                    lastMarkerGroupID2 = tracksToDraw._leaflet_id;
                     
                }
                lensesLayer.bringToFront();
            });
            var newData3 = $.ajax({
                url: urlString3,
                type: 'GET',
                dataType:'json',
                success: console.log("4 successfully loaded!"),
                error: function (xhr) {
                    alert(xhr.statusText)
                }
                
            })
            $.when(newData3).done(function() {
                
                console.log("Im removing the map now and adding new ones afterwards")
                
                if(newData3.responseJSON.features != null){
                    var tracksToDraw = L.geoJson(newData3.responseJSON,firstStyle);
                    tracksToDraw.addTo(markerGroup3);
                    lastMarkerGroupID3 = tracksToDraw._leaflet_id;
                     
                }
                lensesLayer.bringToFront();
            });
            
        }

        /*function deleteAttribute(lngLat, radius, _attribute, _encoding){
            console.log("Delete att");
            var metresPerPixel = 40075016.686 * Math.abs(Math.cos(lngLat.lat * 180/Math.PI)) / Math.pow(2, map.getZoom()+8);
            var pixelsInRadius = radius / metresPerPixel;
            if(defaultLayerFlag){
                    defaultLayer.eachLayer(function (layer) {
                        console.log("Each layer");
                        var yourDistance = L.GeometryUtil.closest(map, layer, lngLat).distance;
                        //var layersActive = layersWithin(map, layer, lngLat, pixelsInRadius)
                        if ( yourDistance <= pixelsInRadius){
                            switch(_encoding) {
                                case "color":
                                    layer.setStyle({color: '#FF6347'});
                                    layer.setStyle({opacity:1.0});
                                        attLensesArray.forEach(function(item, index, array) {
                                            console.log(item, index);
                                            if(item.att == "vel"){ //if same type dont perform? detetar layers em conjunto, guardar valor em array d layers por lente e dps apagar.
                                                var layerToPaint = L.featureGroup().addTo(attLenResults);
                                                item.updateLayer(layer, layerToPaint);
                                            }
                                            else item.updateLayer(layer, null)
                                        });
                                    break;
                                case "brightness":
                                    layer.setStyle({color: '#FF6347'});
                                    attLensesArray.forEach(function(item, index, array) {
                                        console.log(item, index);
                                        item.updateLayer(layer)
                                    });
                                    break;
                                case "opacity":
                                    console.log("Returning Opacity to 1");
                                    layer.setStyle({opacity:1});
                                    break;
                                case "width":
                                    console.log("Returning Width to 1.5");
                                    layer.setStyle({"weight": 1.5});
                                    break;
                            }
                        }               
                    });
            }
            else{
                if(lastMarkerGroupID3 !=null && map.hasLayer(markerGroup3)){
                    markerGroup3.getLayer(lastMarkerGroupID3).eachLayer(function (layer) {
                        console.log("Each layer");
                        var yourDistance = L.GeometryUtil.closest(map, layer, lngLat).distance;
                        //var layersActive = layersWithin(map, layer, lngLat, pixelsInRadius)
                        if ( yourDistance <= pixelsInRadius){
                            switch(_encoding) {
                                case "color":
                                    layer.setStyle({color: '#FF6347'});
                                    layer.setStyle({opacity:1.0});
                                        attLensesArray.forEach(function(item, index, array) {
                                            console.log(item, index);
                                            if(item.att == "vel"){
                                                var layerToPaint = L.featureGroup().addTo(attLenResults);
                                                item.updateLayer(layer, layerToPaint);
                                            }
                                            else item.updateLayer(layer, null)
                                        });
                                    break;
                                case "brightness":
                                    layer.setStyle({color: '#FF6347'});
                                    attLensesArray.forEach(function(item, index, array) {
                                        console.log(item, index);
                                        item.updateLayer(layer)
                                    });
                                    break;
                                case "opacity":
                                    console.log("Returning Opacity to 1");
                                    layer.setStyle({opacity:1});
                                    break;
                                case "width":
                                    console.log("Returning Width to 1.5");
                                    layer.setStyle({"weight": 1.5});
                                    break;
                            }
                        }               
                    });
                }
                if(lastMarkerGroupID2 !=null && map.hasLayer(markerGroup2)){
                        markerGroup2.getLayer(lastMarkerGroupID2).eachLayer(function (layer) {
                            var yourDistance = L.GeometryUtil.closest(map, layer, lngLat).distance;
                            //var layersActive = layersWithin(map, layer, lngLat, pixelsInRadius)
                            if ( yourDistance <= pixelsInRadius){
                                switch(_encoding) {
                                    case "color":
                                        layer.setStyle({color: '#FF6347'});
                                        layer.setStyle({opacity:1.0});
                                        attLensesArray.forEach(function(item, index, array) {
                                            console.log(item, index);
                                            if(item.att == "vel"){
                                                var layerToPaint = L.featureGroup().addTo(attLenResults);
                                                item.updateLayer(layer, layerToPaint);
                                            }
                                            else item.updateLayer(layer, null)
                                        });
                                        break;
                                    case "brightness":
                                        layer.setStyle({color: '#FF6347'});
                                        attLensesArray.forEach(function(item, index, array) {
                                            console.log(item, index);
                                            item.updateLayer(layer)
                                        });
                                        break;
                                    case "opacity":
                                        layer.setStyle({opacity:1});
                                        break;
                                    case "width":
                                        layer.setStyle({"weight": 1.5});
                                        break;
                                }
                            }               
                        });
                }
                if(lastMarkerGroupID1 !=null && map.hasLayer(markerGroup1)){
                        markerGroup1.getLayer(lastMarkerGroupID1).eachLayer(function (layer) {
                            var yourDistance = L.GeometryUtil.closest(map, layer, lngLat).distance;
                            //var layersActive = layersWithin(map, layer, lngLat, pixelsInRadius)
                            if ( yourDistance <= pixelsInRadius){
                                switch(_encoding) {
                                    case "color":
                                        layer.setStyle({color: '#FF6347'});
                                        layer.setStyle({opacity:1.0});
                                        attLensesArray.forEach(function(item, index, array) {
                                            console.log(item, index);
                                            if(item.att == "vel"){
                                                var layerToPaint = L.featureGroup().addTo(attLenResults);
                                                item.updateLayer(layer, layerToPaint);
                                            }
                                            else item.updateLayer(layer, null)
                                        });
                                        break;
                                    case "brightness":
                                        layer.setStyle({color: '#FF6347'});
                                        attLensesArray.forEach(function(item, index, array) {
                                            console.log(item, index);
                                            item.updateLayer(layer)
                                        });
                                        break;
                                    case "opacity":
                                        layer.setStyle({opacity:1});
                                        break;
                                    case "width":
                                        layer.setStyle({"weight": 1.5});
                                        break;
                                }
                            }               
                        });
                }
                if(lastMarkerGroupID !=null && map.hasLayer(markerGroup)){
                        markerGroup.getLayer(lastMarkerGroupID).eachLayer(function (layer) {
                            var yourDistance = L.GeometryUtil.closest(map, layer, lngLat).distance;
                            //var layersActive = layersWithin(map, layer, lngLat, pixelsInRadius)
                            if ( yourDistance <= pixelsInRadius){
                                switch(_encoding) {
                                    case "color":
                                        layer.setStyle({color: '#FF6347'});
                                        layer.setStyle({opacity:1.0});
                                        attLensesArray.forEach(function(item, index, array) {
                                            console.log(item, index);
                                            if(item.att == "vel"){
                                                var layerToPaint = L.featureGroup().addTo(attLenResults);
                                                item.updateLayer(layer, layerToPaint);
                                            }
                                            else item.updateLayer(layer, null)
                                        });
                                        break;
                                    case "brightness":
                                        layer.setStyle({color: '#FF6347'});
                                        attLensesArray.forEach(function(item, index, array) {
                                            console.log(item, index);
                                            item.updateLayer(layer)
                                        });
                                        break;
                                    case "opacity":
                                        layer.setStyle({opacity:1.0});
                                        break;
                                    case "width":
                                        layer.setStyle({"weight": 1.5});
                                        break;
                                }
                            }               
                        });
                } 
            } 
        }*/

        /////
        /////
        /////

        
        /////
        ///// Menus for lens creation
        /////

        function queryLensMenu(e){
            lensPreCreationLayer.clearLayers();
            var previewCircle = L.circle(e.latlng, {
                    color: 'red',
                    fillColor: '#f03',
                    fillOpacity: 0.5,
                    radius: 5000
                });
            previewCircle.addTo(lensPreCreationLayer);
            popup
                .setLatLng(e.latlng)
                .setContent("You clicked the map at " + e.latlng.toString() + 
                "<input id='radiusBox' type='range' min='1' max='10000' val='5000' />" + 
                "<input type='text' id='amountVel' readonly style=' border:0; color:#f6f31f1; font-weight:bold;'>" + 
                "<div id='maxMinBoundsVel'></div>" + 
                "<input type='text' id='amountLength' readonly style='width:250px; border:0; color:#669911; font-weight:bold;'>" + 
                "<div id='maxMinBoundsLength'></div>" +
                "<input type='text' id='amountTimeInterval' readonly style='width:310px; border:0; color:#f6931f; font-weight:bold;'>" + 
                "<div id='maxMinBoundsTimeInterval'></div>" + 
                "<input type='text' id='amountTimeDuration' readonly style='width:310px; border:0; color:#23339f; font-weight:bold;'>" + 
                "<div id='maxMinBoundsTimeDuration'></div>" + 
                "<input type='button' value='Create Pass by Lens' class='marker-create-button'/>" + 
                "<input type='button' value='Create Start point Lens' class='marker-create-Start-button'/>" + 
                "<input type='button' value='Create End point Lens' class='marker-create-End-button'/>" + 
                "<input type='button' value='Create average Velocity Lens' class='marker-create-VelocityAVG-button'/>" + 
                "<input type='button' value='Create Length Lens' class='marker-create-length-button'/>" + 
                "<input type='button' value='Create Time Interval Lens' class='marker-create-timeInterval-button'/>" +
                "<input type='button' value='Create Time Duration Lens' class='marker-create-timeDuration-button'/>").openOn(map);
            map.on('popupclose', function(e) {
                    lensPreCreationLayer.clearLayers();
                })
            var location= e.latlng;
            $('.marker-create-button').click(function () {
                console.log ($('#radiusBox').val() );
                if ($('#radiusBox').val() == "" || $('#radiusBox').val() <= 0 || $('#radiusBox').val() > 10000) {
                    popup2
                        .setLatLng(e.latlng)
                        .setContent("Fill with a value of 1 until 10000" )
                        .openOn(map);
                }
                else {
                    createQuery(location.lng, location.lat, $('#radiusBox').val(),"Default",0,0);
                }
            });
            $('.marker-create-Start-button').click(function () {
                console.log ($('#radiusBox').val() );
                if ($('#radiusBox').val() == "" || $('#radiusBox').val() <= 0 || $('#radiusBox').val() > 10000) {
                    popup2
                        .setLatLng(e.latlng)
                        .setContent("Fill with a value of 1 until 10000" )
                        .openOn(map);
                }
                else {
                    createQuery(location.lng, location.lat, $('#radiusBox').val(),"Start",0,0);
                }
            });
            $('.marker-create-End-button').click(function () {
                console.log ($('#radiusBox').val() );
                if ($('#radiusBox').val() == "" || $('#radiusBox').val() <= 0 || $('#radiusBox').val() > 10000) {
                    popup2
                        .setLatLng(e.latlng)
                        .setContent("Fill with a value of 1 until 10000" )
                        .openOn(map);
                }
                else {
                    createQuery(location.lng, location.lat, $('#radiusBox').val(),"End",0,0);
                }
            });
            $('.marker-create-VelocityAVG-button').click(function () {
                console.log ($('#radiusBox').val() );
                if ($('#radiusBox').val() == "" || $('#radiusBox').val() <= 0 || $('#radiusBox').val() > 10000) {
                    popup2
                        .setLatLng(e.latlng)
                        .setContent("Fill with a value of 1 until 10000" )
                        .openOn(map);
                }
                else {
                    createQuery(location.lng, location.lat, $('#radiusBox').val(),"Vel_avg",minValueVel,maxValueVel);
                }
            });
            $('.marker-create-length-button').click(function () {
                console.log ($('#radiusBox').val() );
                if ($('#radiusBox').val() == "" || $('#radiusBox').val() <= 0 || $('#radiusBox').val() > 10000) {
                    popup2
                        .setLatLng(e.latlng)
                        .setContent("Fill with a value of 1 until 10000" )
                        .openOn(map);
                }
                else {
                    createQuery(location.lng, location.lat, $('#radiusBox').val(),"Length",minValueLength,maxValueLength);
                }
            });
            $('.marker-create-timeInterval-button').click(function () {
                console.log ($('#radiusBox').val() );
                if ($('#radiusBox').val() == "" || $('#radiusBox').val() <= 0 || $('#radiusBox').val() > 10000) {
                    popup2
                        .setLatLng(e.latlng)
                        .setContent("Fill with a value of 1 until 10000" )
                        .openOn(map);
                }
                else {
                    createQuery(location.lng, location.lat, $('#radiusBox').val(),"Time_Interval",minValueTime,maxValueTime);
                }
            });
            $('.marker-create-timeDuration-button').click(function () {
                console.log ($('#radiusBox').val() );
                if ($('#radiusBox').val() == "" || $('#radiusBox').val() <= 0 || $('#radiusBox').val() > 10000) {
                    popup2
                        .setLatLng(e.latlng)
                        .setContent("Fill with a value of 1 until 10000" )
                        .openOn(map);
                }
                else {
                    createQuery(location.lng, location.lat, $('#radiusBox').val(),"Time_Duration",minValueTimeDuration,maxValueTimeDuration);
                }
            });
            
            $( function() {
                $( "#radiusValue" ).slider({
                range: true,
                min: 0,
                max: 500,
                values: [ 0, 500 ],
                slide: function( event, ui ) {
                    minValueVel =ui.values[ 0 ];
                    maxValueVel =ui.values[ 1 ];
                    $( "#amountVel" ).val( "Km/h " + ui.values[ 0 ] + " - Km/h " + ui.values[ 1 ] );
                }
                });
                $( "#amountVel" ).val( "Km/h" + $( "#slider-range" ).slider( "values", 0 ) +
                " - Km/h" + $( "#slider-range" ).slider( "values", 1 ) );
            } );

            $( function() {
                $( "#maxMinBoundsVel" ).slider({
                range: true,
                min: 0,
                max: 500,
                values: [ 0, 500 ],
                slide: function( event, ui ) {
                    minValueVel =ui.values[ 0 ];
                    maxValueVel =ui.values[ 1 ];
                    $( "#amountVel" ).val( "Km/h " + ui.values[ 0 ] + " - Km/h " + ui.values[ 1 ] );
                }
                });
                $( "#amountVel" ).val( "Km/h" + $( "#slider-range" ).slider( "values", 0 ) +
                " - Km/h" + $( "#slider-range" ).slider( "values", 1 ) );
            } );

            $( function() {
                $( "#maxMinBoundsLength" ).slider({
                range: true,
                min: 1,
                max: 500000,
                values: [ 1, 300000 ],
                slide: function( event, ui ) {
                    minValueLength =ui.values[ 0 ];
                    maxValueLength =ui.values[ 1 ];
                    $( "#amountLength" ).val( "Meters" + ui.values[ 0 ] + " - Meters" + ui.values[ 1 ] );
                }
                });
                $( "#amountLength" ).val( "Meters " + $( "#slider-range" ).slider( "values", 0 ) +
                " - Meters " + $( "#slider-range" ).slider( "values", 1 ) );
            } );

            $( function() {
                $( "#maxMinBoundsTimeInterval" ).slider({
                range: true,
                min: 1201959044 , // 2008-02-02 13:30:44
                max: 1202492358 , // 2008-02-08 17:39:18
                values: [ 1201959044 , 1202492358  ],
                slide: function( event, ui ) {
                    minValueTime =ui.values[ 0 ];
                    maxValueTime =ui.values[ 1 ];
                    $( "#amountTimeInterval" ).val(Unix_timestamp(minValueTime * 1000) + " - " + Unix_timestamp(maxValueTime * 1000) );
                }
                });
                $( "#amountTimeInterval" ).val($( "#slider-range" ).slider( "values", 0 ) +
                " - " + $( "#slider-range" ).slider( "values", 1 ) );
            } );

            $( function() {
                $( "#maxMinBoundsTimeDuration" ).slider({
                range: true,
                min: 0, // 2008-02-02 13:30:44
                max: 85839, // 2008-02-08 17:39:18
                values: [ 0, 85839 ],
                slide: function( event, ui ) {
                    minValueTimeDuration =ui.values[ 0 ];
                    maxValueTimeDuration =ui.values[ 1 ];
                    $( "#amountTimeDuration" ).val(minValueTimeDuration + " - " + maxValueTimeDuration);
                }
                });
                $( "#amountTimeDuration" ).val( "Min duration " + $( "#slider-range" ).slider( "values", 0 ) +
                " - Max time " + $( "#slider-range" ).slider( "values", 1 ) );
            } );

            $('#radiusBox').on('input',function(){
                var myVar = $(this).val();
                previewCircle.setRadius( myVar);
                
            });
        }
        function attributeLensMenu(e){
            lensPreCreationLayer.clearLayers();
            var previewCircle = L.circle(e.latlng, {
                    color: 'red',
                    fillColor: '#f03',
                    fillOpacity: 0.5,
                    radius: 5000
                });
            previewCircle.addTo(lensPreCreationLayer);
            popup
                .setLatLng(e.latlng)
                .setContent("You clicked the map at " + e.latlng.toString() + 
                "<input id='radiusBox' type='range' min='1' max='10000' val='5000' />" + 
                "<div class='dropdown'><button class='dropbtn'>Dropdown</button><div class='dropdown-content'>" + 
                "<button class='dropbtnOpt-length'>Length</button>"+
                "<button class='dropbtnOpt-velocity'>Velocity</button>"+
                "<button class='dropbtnOpt-time'>Time</button>"+
                "<button class='dropbtnOpt-duration'>Duration</button>"+
                "</div></div>" +
                "<div class='dropdown'><button class='dropbtn'>Dropdown</button><div class='dropdown-content'>" + 
                "<button class='dropbtnOpt-color'>Color</button>"+
                "<button class='dropbtnOpt-width'>Width</button>"+
                "<button class='dropbtnOpt-brightness'>Brightness</button>"+
                "<button class='dropbtnOpt-opacity'>Opacity</button>"+
                "</div></div>" +
                "<input type='button' value='Create Attribute Lens' class='attribute-button'/>").openOn(map);
            map.on('popupclose', function(e) {
                    lensPreCreationLayer.clearLayers();
                })
            var location= e.latlng;
            $('.attribute-button').click(function () {
                console.log ($('#radiusBox').val() );
                if ($('#radiusBox').val() == "" || $('#radiusBox').val() <= 0 || $('#radiusBox').val() > 10000) {
                    popup2
                        .setLatLng(e.latlng)
                        .setContent("Fill with a value of 1 until 10000" )
                        .openOn(map);
                }
                else {
                    createALens(location, $('#radiusBox').val(),attributeFuncVar,encodingFuncVar).createLayers();
                }
            });
            $('.dropbtnOpt-length').click(function () {
                    attributeFuncVar = "length"
            });
            $('.dropbtnOpt-velocity').click(function () {
                    attributeFuncVar = "vel"
            });
            $('.dropbtnOpt-time').click(function () {
                    attributeFuncVar = "time"
            });
            $('.dropbtnOpt-duration').click(function () {
                    attributeFuncVar = "duration"
            });

            $('.dropbtnOpt-color').click(function () {
                    encodingFuncVar = "color"
            });
            $('.dropbtnOpt-width').click(function () {
                    encodingFuncVar = "width"
            });
            $('.dropbtnOpt-brightness').click(function () {
                    encodingFuncVar = "brightness"
            });
            $('.dropbtnOpt-opacity').click(function () {
                    encodingFuncVar = "opacity"
            });



            $('#radiusBox').on('input',function(){
                var myVar = $(this).val();
                previewCircle.setRadius( myVar);

            });
        }

        /////
        /////
        /////

        /////
        ///// Create Lens' circle (lens it self)
        /////

        function createLens(lng, lat, radiusQuery, _type, minVal, maxVal){
            var lens = { type: _type, 
                areaQuery : L.circle([lat, lng], {
                    color: 'DarkRed',
                    fillColor: 'red',
                    fillOpacity: 0.6,
                    radius: radiusQuery
                }).addTo(lensesLayer),
                colorSuccess : function() {
                    if(_type == "Default"){
                        console.log("I will now paint the Pass by circle again ....")
                        lens.areaQuery.setStyle({color: 'DodgerBlue', fillColor: 'DodgerBlue', fillOpacity: 0.2});
                    }
                    else if(_type == "Start"){
                        console.log("I will now paint the Start circle again ....")
                        lens.areaQuery.setStyle({color: 'MediumSeaGreen', fillColor: 'MediumSeaGreen', fillOpacity: 0.2});
                    }
                    else if(_type == "End"){
                        console.log("I will now paint the End circle again ....")
                        lens.areaQuery.setStyle({color: 'Violet', fillColor: 'Violet', fillOpacity: 0.2});
                    }
                    else if(_type == "Vel_avg"){
                        console.log("I will now paint the End circle again ....")
                        lens.areaQuery.setStyle({color: 'orange', fillColor: 'orange', fillOpacity: 0.2});
                    }
                    else if(_type == "Length"){
                        console.log("I will now paint the End circle again ....")
                        lens.areaQuery.setStyle({color: 'SlateBlue', fillColor: 'SlateBlue', fillOpacity: 0.2});
                    }
                    else if(_type == "Time_Interval"){
                        console.log("I will now paint the End circle again ....")
                        lens.areaQuery.setStyle({color: 'purple', fillColor: 'purple', fillOpacity: 0.2});
                    }
                    else if(_type == "Time_Duration"){
                        console.log("I will now paint the End circle again ....")
                        lens.areaQuery.setStyle({color: 'DarkTurquoise ', fillColor: 'DarkTurquoise ', fillOpacity: 0.2});
                    }
                }
            };
            
            
            lens.areaQuery.bindPopup("<input type='button' value='Delete this lens' class='marker-delete-button'/>")
            lens.areaQuery.on("popupopen", function() {
            //var tempMarkerGeoJSON = this.toGeoJSON();

            //var lID = tempMarker._leaflet_id; // Getting Leaflet ID of this marker

            // To remove marker on click of delete
            $('.marker-delete-button:visible').click(function () {
                lensesLayer.removeLayer(lens.areaQuery);
                
                if(lastMarkerGroupID !=null){
                    markerGroup.removeLayer(lastMarkerGroupID);
                    lastMarkerGroupID = null;
                }
                if(lastMarkerGroupID1 !=null){
                    markerGroup1.removeLayer(lastMarkerGroupID1);
                    lastMarkerGroupID1 = null;
                }
                if(lastMarkerGroupID2 !=null){
                    markerGroup2.removeLayer(lastMarkerGroupID2);
                    lastMarkerGroupID2 = null;
                }
                if(lastMarkerGroupID3 !=null){
                    markerGroup3.removeLayer(lastMarkerGroupID3);
                    lastMarkerGroupID3 = null;
                }
                deleteQuery(lng, lat, radiusQuery, _type, minVal, maxVal);
                attLensesArray.forEach(function(item, index, array) {
                    item.updateALL();
                });
                });
                
            }) ; 
            return lens
        }

        function createALens(lngLat, radiusQuery, _attribute, _encoding){
            var lens = { 
                areaQuery : L.circle([lngLat.lat, lngLat.lng], {
                    color: 'DarkRed',
                    fillColor: 'red',
                    fillOpacity: 0.6,
                    radius: radiusQuery
                }).addTo(lensesLayer),
                lngLat : lngLat,
                radiusQuery : radiusQuery,
                lID : null,
                att : _attribute,
                enc : _encoding,
                intersections: [],
                bounds : null,
                setLngLat : function (value){
                    this.lngLat = value;
                },
                setBounds : function (value){
                    this.bounds = value;
                },
                setlID : function (value){
                    this.lID = value;
                },
                getLngLat : function (){
                    return this.lngLat;
                },
                getBound : function (){
                    return this.bounds;
                },
                getlID : function (){
                    return this.lID;
                },
                colorSuccess : function() {
                    //if(_attribute == "length"){
                    console.log("I will now paint the Pass by circle again ....")
                    this.areaQuery.setStyle({color: '#FFFFFF', fillColor: '#FFFFFF', fillOpacity: 0.01});
                    
                },
                updateLayer : function(layer, value){
                    //var layersActive = layersWithin(map, layer, lngLat, pixelsInRadius)
                    if ( this.areaQuery.getBounds().intersects(layer.getBounds())){
                        switch(_attribute) {
                            case "length":
                                lengthAtt(layer, value,_encoding);
                                break;
                            case "duration":
                                durationAtt(layer,value, _encoding);
                                break;
                            case "vel":
                                velocityAtt(layer,value,_encoding);
                                break;
                            case "time":
                                timeAtt(layer,value, _encoding);
                                break;
                        }   
                        
                    //}
                    }
                    else console.log("Layer not within the circle")
                },

                createLayers : function(){
                    var attLayer = L.featureGroup().addTo(attLenResults);
                    var _attLayer = L.featureGroup().addTo(attLayer);
                    var _attLayer1 = L.featureGroup().addTo(attLayer);
                    var _attLayer2 = L.featureGroup().addTo(attLayer);
                    var _attLayer3 = L.featureGroup().addTo(attLayer);
                    
                        // Create URL
                    var urlString3 = "attQuery/trajectory_lines/"  + this.lngLat.lng + "/" + this.lngLat.lat + "/" + this.radiusQuery;
                    var urlString2 = "attQuery/trajectory_lines1/" + this.lngLat.lng + "/" + this.lngLat.lat + "/" + this.radiusQuery;
                    var urlString1 = "attQuery/trajectory_lines2/" + this.lngLat.lng + "/" + this.lngLat.lat + "/" + this.radiusQuery;
                    var urlString  = "attQuery/trajectory_lines3/" + this.lngLat.lng + "/" + this.lngLat.lat + "/" + this.radiusQuery;
                    
                    this.lID = attLayer._leaflet_id;
                    var newData = $.ajax({
                        url: urlString,
                        type: 'GET',
                        dataType:'json',
                        success: console.log("Data successfully loaded!"),
                        error: function (xhr) {
                            alert(xhr.statusText)
                        }
                        
                    }) 
                    $.when(newData).done(function() {
                        
                        if(newData.responseJSON.features != null){
                            console.log(newData.responseJSON.features);
                            newData.responseJSON.features.forEach(function(item, index, array) {
                                var tracksToDraw = L.geoJson(item,firstStyle);
                                switch(lens.att) {
                                    case "length":
                                        lengthAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                    case "duration":
                                        // code block
                                        durationAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                    case "vel":
                                        velocityAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                    case "time":
                                        timeAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                } 
                                lens.intersections.forEach(function(lensInt, index, array) {
                                    console.log(lensInt.areaQuery);
                                    console.log(tracksToDraw.getBounds());
                                    if(lensInt.areaQuery.getBounds().intersects(tracksToDraw.getBounds())){

                                        console.log("This layer intersects the other lenses");
                                        console.log(lensInt.areaQuery.getBounds().intersects(tracksToDraw.getBounds()));
                                        console.log(lensInt);
                                        console.log(tracksToDraw);
                                        lensInt.updateLayer(tracksToDraw,item.properties)
                                    }
                                });
                                tracksToDraw.addTo(_attLayer);
                            });
                            
                        }
                    }); 
                    var newData1 = $.ajax({
                        url: urlString1,
                        type: 'GET',
                        dataType:'json',
                        success: console.log("Data successfully loaded!"),
                        error: function (xhr) {
                            alert(xhr.statusText)
                        }
                        
                    }) 
                    $.when(newData1).done(function() {
                        if(newData1.responseJSON.features != null){
                            console.log(newData1.responseJSON.features);
                            newData1.responseJSON.features.forEach(function(item, index, array) {
                                var tracksToDraw = L.geoJson(item,firstStyle);
                                switch(lens.att) {
                                    case "length":
                                        lengthAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                    case "duration":
                                        // code block
                                        durationAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                    case "vel":
                                        velocityAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                    case "time":
                                        timeAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                } 
                                lens.intersections.forEach(function(lensInt, index, array) {
                                    console.log(lensInt, index);
                                    if(lensInt.areaQuery.getBounds().intersects(tracksToDraw.getBounds())){
                                        lensInt.updateLayer(tracksToDraw,item.properties)
                                    }
                                });
                                tracksToDraw.addTo(_attLayer1);
                            });
                            
                        }
                    });
                    var newData2 = $.ajax({
                        url: urlString2,
                        type: 'GET',
                        dataType:'json',
                        success: console.log("Data successfully loaded!"),
                        error: function (xhr) {
                            alert(xhr.statusText)
                        }
                        
                    }) 
                    $.when(newData2).done(function() {
                        if(newData2.responseJSON.features != null){
                            console.log(newData2.responseJSON.features);
                            newData2.responseJSON.features.forEach(function(item, index, array) {
                                var tracksToDraw = L.geoJson(item,firstStyle);
                                switch(lens.att) {
                                    case "length":
                                        lengthAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                    case "duration":
                                        // code block
                                        durationAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                    case "vel":
                                        velocityAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                    case "time":
                                        timeAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                } 
                                lens.intersections.forEach(function(lensInt, index, array) {
                                    console.log(lensInt, index);
                                    if(lensInt.areaQuery.getBounds().intersects(tracksToDraw.getBounds())){
                                        lensInt.updateLayer(tracksToDraw,item.properties)
                                    }
                                });
                                tracksToDraw.addTo(_attLayer2);
                            });
                            
                        }
                    });
                    var newData3 = $.ajax({
                        url: urlString3,
                        type: 'GET',
                        dataType:'json',
                        success: console.log("Data successfully loaded!"),
                        error: function (xhr) {
                            alert(xhr.statusText)
                        }
                        
                    }) 
                    $.when(newData3).done(function() {
                        if(newData3.responseJSON.features != null){
                            console.log(newData3.responseJSON.features);
                            newData3.responseJSON.features.forEach(function(item, index, array) {
                                var tracksToDraw = L.geoJson(item,firstStyle);
                                switch(lens.att) {
                                    case "length":
                                        lengthAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                    case "duration":
                                        // code block
                                        durationAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                    case "vel":
                                        velocityAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                    case "time":
                                        timeAtt(tracksToDraw, item.properties, lens.enc);
                                        break;
                                } 
                                lens.intersections.forEach(function(lensInt, index, array) {
                                    console.log(lensInt, index);
                                    if(lensInt.areaQuery.getBounds().intersects(tracksToDraw.getBounds())){
                                        lensInt.updateLayer(tracksToDraw,item.properties)
                                    }
                                });
                                tracksToDraw.addTo(_attLayer3);
                            });
                            
                            
                        }
                    });
                    this.colorSuccess();
                    
                },
                updateALL : function (){
                    attLenResults.removeLayer(this.lID);
                    this.createLayers();
                },
                deleteAndUpdateOthers: function(){
                    attLenResults.removeLayer(this.lID);
                    attLensesArray.splice( attLensesArray.indexOf(this),1);
                    
                    attLensesArray.forEach(function (lensInGlobalArray,index,array){
                        if(lensInGlobalArray.intersections.indexOf(lens) !=-1) {
                            console.log(lensInGlobalArray.intersections);
                            console.log("I will now delete the lens from this ones intersection list")
                            lensInGlobalArray.intersections.splice(lensInGlobalArray.intersections.indexOf(lens),1);
                            console.log(lensInGlobalArray.intersections);
                            var layerofItem = attLenResults.getLayer(lensInGlobalArray.lID);
                            layerofItem.eachLayer(function (layerHolder) {
                                layerHolder.eachLayer(function (layer) {
                                    if (lens.getBound().intersects(layer.getBounds())){
                                        console.log("This layer is inside the bounds");
                                        switch(lens.enc) {
                                            case "color":
                                                layer.setStyle({color: '#FF6347'});
                                                lensInGlobalArray.updateLayer(layer, layer._layers[layer._leaflet_id - 1].feature.properties);
                                                lensInGlobalArray.intersections.forEach(function(itemInterLens, index, array) {
                                                    if (itemInterLens.areaQuery.getBounds().intersects(layer.getBounds())){
                                                        itemInterLens.updateLayer(layer, layer._layers[layer._leaflet_id - 1].feature.properties);
                                                    }
                                                });
                                                break;
                                            case "brightness":
                                                layer.setStyle({color: '#FF6347'});
                                                lensInGlobalArray.updateLayer(layer, layer._layers[layer._leaflet_id - 1].feature.properties);
                                                lensInGlobalArray.intersections.forEach(function(itemInterLens, index, array) {
                                                    if (itemInterLens.areaQuery.getBounds().intersects(layer.getBounds())){
                                                        itemInterLens.updateLayer(layer, layer._layers[layer._leaflet_id - 1].feature.properties);
                                                    }
                                                });
                                                break;
                                            case "opacity":
                                                console.log("Returning Opacity to 1");
                                                layer.setStyle({opacity:1});
                                                break;
                                            case "width":
                                                console.log("Returning Width to 1.5");
                                                layer.setStyle({"weight": 1.5});
                                                break;
                                        }
                                    }
                                });
                            });

                        }
                    });

                    //Previous method
                    //deleteAttribute(lngLat, radiusQuery, _attribute, _encoding);
                }
            };

            lens.setBounds(lens.areaQuery.getBounds());

            attLensesArray.forEach(function(item, index, array) {
                console.log(item, index);
                if(lens.areaQuery.getBounds().intersects(item.areaQuery.getBounds())){
                    lens.intersections.push(item);
                }
            });
            
            attLensesArray.push(lens);

            console.log(attLensesArray);

            lens.areaQuery.on({
                mousedown: function () {
                    map.dragging.disable();
                    map.on('mousemove', function (e) {
                        lens.areaQuery.setLatLng(e.latlng);
                        lens.lngLat = e.latlng;
                    });
                },
                mouseup: function(){
                    map.removeEventListener('mousemove');
                    map.dragging.enable();
                    lens.deleteAndUpdateOthers();

                    attLensesArray.forEach(function(item, index, array) {
                        console.log(item, index);
                        if(lens.areaQuery.getBounds().intersects(item.areaQuery.getBounds())){
                            lens.intersections.push(item);
                        }
                    });
                    attLensesArray.push(lens);
                    lens.createLayers();
                    lens.setBounds(lens.areaQuery.getBounds());
                }
            }); 
            lens.areaQuery.bindPopup("This lens is taking the attribute " + _attribute + " and encoding it as the " + _encoding + ".\n" + "<input type='button' value='Delete this lens' class='marker-delete-button'/>")
            lens.areaQuery.on("popupopen", function() {
                // To remove marker on click of delete
                $('.marker-delete-button:visible').click(function () {
                    lens.deleteAndUpdateOthers();
                    lensesLayer.removeLayer(lens.areaQuery);
                });
                
            }); 
            return lens
        }

        /////
        /////
        /////

        /////
        /////  Functions per attribute
        /////

        function velocityAtt(layer, properties, encoding){
             // code block
            var velAtt = properties.f5;
            switch(encoding){
                case "color":
                    /*layer.setStyle({opacity:0});
                    var pointsArray = layer.feature.geometry.coordinates;
                    
                    var velArray =  layer.feature.properties.f5;

                    var finalArray = [];
                    
                    for(var i = 0;i < velArray.length;i++ ){
                        finalArray.push([pointsArray[i][1],pointsArray[i][0],velArray[i]]);    
                    }
                    console.log(pointsArray);
                    var hotlineLayer = L.hotline(finalArray, {
                        min: 0,
                        max: 60,
                        palette: {
                            0.0: '#ff0000',
                            0.3: '#ffff00',
                            1.0: '#008800'
                        },
                        weight: 1,
                        outlineColor: '#FFFFFF',
                        outlineWidth: 0
                    });
                    
                    delete finalArray;
                    delete pointsArray;
                    delete velArray;
                    

                    console.log(hotlineLayer);
                    hotlineLayer.addTo(layerToPaint);
                    */

                    if(velAtt <= 1)          {
                            layer.setStyle({color :'#29FF9A'});
                    }
                    else if(velAtt <= 2)     {
                            layer.setStyle({color :'#40E49B'});
                    }
                    else if(velAtt <= 5)    {
                            layer.setStyle({color :'#58CA9C'});
                    }
                    else if(velAtt <= 10)    {
                            layer.setStyle({color :'#70B09D'});
                    }
                    else if(velAtt <= 15)    {
                            layer.setStyle({color :'#88969E'});
                    }
                    else if(velAtt <= 20)    {
                            layer.setStyle({color :'#9F7C9F'});
                    }
                    else if(velAtt <=  30)   {
                            layer.setStyle({color :'#B762A0'});
                    }
                    else if(velAtt <=  50)   {
                            layer.setStyle({color :'#CF48A1'});
                    }
                    else if(velAtt <=  80)   {
                            layer.setStyle({color :'#E72EA2'});
                    }
                    else    layer.setStyle({color :'#FF14A3'});
                    break;
                    
                    break;
                case "brightness":
                    if(velAtt <= 1)          {
                        var colr = ColorLuminance(layer.options.color,-0.95);
                        layer.setStyle({"color":colr});
                    }
                    else if(velAtt <= 2)     {
                        var colr = ColorLuminance(layer.options.color,-0.9);
                        layer.setStyle({"color":colr});
                    }
                    else if(velAtt <= 5)    {
                        var colr = ColorLuminance(layer.options.color,-0.8);
                        layer.setStyle({"color":colr});
                    }
                    else if(velAtt <= 10)    {
                        var colr = ColorLuminance(layer.options.color,-0.65);
                        layer.setStyle({"color":colr});
                    }
                    else if(velAtt <= 15)    {
                        var colr = ColorLuminance(layer.options.color,-0.5);
                        layer.setStyle({"color":colr});
                    }
                    else if(velAtt <= 20)    {
                        var colr = ColorLuminance(layer.options.color,-0.35);
                        layer.setStyle({"color":colr});
                    }
                    else if(velAtt <=  30)   {
                        var colr = ColorLuminance(layer.options.color,-0.2);
                        layer.setStyle({"color":colr});
                    }
                    else if(velAtt <=  50)   {
                        var colr = ColorLuminance(layer.options.color,-0.1);
                        layer.setStyle({"color":colr});
                    }
                    else if(velAtt <=  80)   {
                        var colr = ColorLuminance(layer.options.color,-0.05);
                        layer.setStyle({"color":colr});
                    }
                    else                    console.log("brightness already at 1")
                    break;
                case "opacity":
                
                    break;
                case "width":
                
                    break;
            }
        }

        function lengthAtt(layer,properties, encoding){
             // code block
            var len = properties.f1;
            switch(encoding){
                case "color":
                    if(len <= 250)          layer.setStyle({color :'#29FF9A'}) 
                    else if(len <= 500)     layer.setStyle({color :'#40E49B'})
                    else if(len <= 1000)    layer.setStyle({color :'#58CA9C'}) 
                    else if(len <= 2000)    layer.setStyle({color :'#70B09D'})
                    else if(len <= 4000)    layer.setStyle({color :'#88969E'}) 
                    else if(len <= 8000)    layer.setStyle({color :'#9F7C9F'}) 
                    else if(len <= 16000)   layer.setStyle({color :'#B762A0'})
                    else if(len <= 32000)   layer.setStyle({color :'#CF48A1'})
                    else if (len <= 128000) layer.setStyle({color :'#E72EA2'})
                    else                    layer.setStyle({color :'#FF14A3'})
                    break;
                case "brightness":
                    if(len <= 250)          {
                        var colr = ColorLuminance(layer.options.color,-0.95);
                        layer.setStyle({"color":colr});
                    }
                    else if(len <= 500)     {
                        var colr = ColorLuminance(layer.options.color,-0.9);
                        layer.setStyle({"color":colr});
                    }
                    else if(len <= 1000)    {
                        var colr = ColorLuminance(layer.options.color,-0.8);
                        layer.setStyle({"color":colr});
                    }
                    else if(len <= 2000)    {
                        var colr = ColorLuminance(layer.options.color,-0.65);
                        layer.setStyle({"color":colr});
                    }
                    else if(len <= 4000)    {
                        var colr = ColorLuminance(layer.options.color,-0.5);
                        layer.setStyle({"color":colr});
                    }
                    else if(len <= 8000)    {
                        var colr = ColorLuminance(layer.options.color,-0.35);
                        layer.setStyle({"color":colr});
                    }
                    else if(len <=  16000)   {
                        var colr = ColorLuminance(layer.options.color,-0.2);
                        layer.setStyle({"color":colr});
                    }
                    else if(len <=  32000)   {
                        var colr = ColorLuminance(layer.options.color,-0.1);
                        layer.setStyle({"color":colr});
                    }
                    else if(len <=  128000)   {
                        var colr = ColorLuminance(layer.options.color,-0.05);
                        layer.setStyle({"color":colr});
                    }
                    else                    console.log("brightness already at 1")
                    break;
                case "opacity":
                    if(len <= 250)          layer.setStyle({opacity:0.05});
                    else if(len <= 500)     layer.setStyle({opacity:0.10});
                    else if(len <= 1000)    layer.setStyle({opacity:0.20}); 
                    else if(len <= 2000)    layer.setStyle({opacity:0.35});
                    else if(len <= 4000)    layer.setStyle({opacity:0.5});
                    else if(len <= 8000)    layer.setStyle({opacity:0.65});
                    else if(len <= 16000)   layer.setStyle({opacity:0.8});
                    else if(len <= 32000)   layer.setStyle({opacity:0.9});
                    else if(len <= 128000)  layer.setStyle({opacity:0.95});
                    else                    console.log("Opcacity already at 1")
                    break;
                case "width":
                if(len <= 250)              layer.setStyle({"weight": 0.1});
                    else if(len <= 500)     layer.setStyle({"weight": 0.5});
                    else if(len <= 1000)    layer.setStyle({"weight": 1});
                    else if(len <= 2000)    layer.setStyle({"weight": 1.5});
                    else if(len <= 4000)    layer.setStyle({"weight": 2});
                    else if(len <= 8000)    layer.setStyle({"weight": 2.5});
                    else if(len <= 16000)   layer.setStyle({"weight": 3.5});
                    else if(len <= 32000)   layer.setStyle({"weight": 5});
                    else if(len <= 128000)  layer.setStyle({"weight": 6.5});
                    else                    layer.setStyle({"weight": 8});
                    break;
            }
        }
        
        function durationAtt(layer, properties, encoding){
             // code block
            var dur = properties.f2;
            switch(encoding){
                case "color":
                    if(dur <= "00:01:00")           layer.setStyle({color :'#FFF8DC'}) 
                    else if(dur <= "00:02:00")      layer.setStyle({color :'#FFE4C4'}) 
                    else if(dur <= "00:05:00")      layer.setStyle({color :'#F5DEB3'})
                    else if(dur <= "00:010:00")     layer.setStyle({color :'#DAA520'}) 
                    else if(dur <=  "00:30:00")     layer.setStyle({color :'#D2691E'}) 
                    else                            layer.setStyle({color :'#A52A2A'}) 
                    break;
                case "brightness":
                    if(dur <= "00:01:00")          {
                        var colr = ColorLuminance(layer.options.color,-0.95);
                        layer.setStyle({"color":colr});
                    }
                    else if(dur <= "00:02:00")     {
                        var colr = ColorLuminance(layer.options.color,-0.9);
                        layer.setStyle({"color":colr});
                    }
                    else if(dur <= "00:05:00")    {
                        var colr = ColorLuminance(layer.options.color,-0.8);
                        layer.setStyle({"color":colr});
                    }
                    else if(dur <= "00:10:00")    {
                        var colr = ColorLuminance(layer.options.color,-0.5);
                        layer.setStyle({"color":colr});
                    }
                    else if(dur <=  "00:30:00")   {
                        var colr = ColorLuminance(layer.options.color,-0.2);
                        layer.setStyle({"color":colr});
                    }
                    else                    console.log("brightness already at 1")
                    break;
                case "opacity":
                    if(dur <= "00:01:00")           layer.setStyle({opacity:0.05});
                    else if(dur <= "00:02:00")      layer.setStyle({opacity:0.15}); 
                    else if(dur <= "00:05:00")      layer.setStyle({opacity:0.3});
                    else if(dur <= "00:10:00")      layer.setStyle({opacity:0.55});
                    else if(dur <=  "00:30:00")     layer.setStyle({opacity:0.8});
                    else                            console.log("Opcacity already at 1")
                    break;
                case "width":
                    if(dur <= "00:01:00")           layer.setStyle({"weight": 0.2});
                    else if(dur <= "00:02:00")      layer.setStyle({"weight": 0.8});
                    else if(dur <= "00:05:00")      layer.setStyle({"weight": 1.5});
                    else if(dur <= "00:10:00")      layer.setStyle({"weight": 2.5});
                    else if(dur <=  "00:30:00")     layer.setStyle({"weight": 3.5});
                    else                            layer.setStyle({"weight": 5});
                    break;
            }
        }

         function timeAtt(layer, properties, encoding){
            // 2008-02-02 13:30:44
            // 2008-02-08 17:39:18
            // code block
            var tim = properties.f3;
            switch(encoding){
                case "color":
                    if(tim <= "2008-02-03 13:30:44")            layer.setStyle({color :'#FFF8DC'}) 
                    else if(tim <= "2008-02-04 13:30:44")       layer.setStyle({color :'#FFE4C4'}) 
                    else if(tim <= "2008-02-05 13:30:44")       layer.setStyle({color :'#F5DEB3'})
                    else if(tim <= "2008-02-06 13:30:44")       layer.setStyle({color :'#DAA520'}) 
                    else if(tim <=  "2008-02-07 13:30:44")      layer.setStyle({color :'#D2691E'}) 
                    else                                        layer.setStyle({color :'#A52A2A'}) 
                    break;
                case "brightness":
                    if(tim <= "2008-02-03 13:30:44")          {
                        var colr = ColorLuminance(layer.options.color,-0.95);
                        layer.setStyle({"color":colr});
                    }
                    else if(tim <= "2008-02-04 13:30:44")     {
                        var colr = ColorLuminance(layer.options.color,-0.9);
                        layer.setStyle({"color":colr});
                    }
                    else if(tim <= "2008-02-05 13:30:44")    {
                        var colr = ColorLuminance(layer.options.color,-0.8);
                        layer.setStyle({"color":colr});
                    }
                    else if(tim <= "2008-02-06 13:30:44")    {
                        var colr = ColorLuminance(layer.options.color,-0.5);
                        layer.setStyle({"color":colr});
                    }
                    else if(tim <= "2008-02-07 13:30:44")   {
                        var colr = ColorLuminance(layer.options.color,-0.2);
                        layer.setStyle({"color":colr});
                    }
                    else                    console.log("brightness already at 1")
                    break;
                case "opacity":
                    if(tim <= "2008-02-03 13:30:44")            layer.setStyle({opacity:0.05});
                    else if(tim <= "2008-02-04 13:30:44")       layer.setStyle({opacity:0.15}); 
                    else if(tim <= "2008-02-05 13:30:44")       layer.setStyle({opacity:0.3});
                    else if(tim <= "2008-02-06 13:30:44")       layer.setStyle({opacity:0.55});
                    else if(tim <= "2008-02-07 13:30:44")       layer.setStyle({opacity:0.8});
                    else                                        console.log("Opcacity already at 1")
                    break;
                case "width":
                    if(tim <= "2008-02-03 13:30:44")            layer.setStyle({"weight": 0.2});
                    else if(tim <= "2008-02-04 13:30:44")       layer.setStyle({"weight": 0.8});
                    else if(tim <= "2008-02-05 13:30:44")       layer.setStyle({"weight": 1.5});
                    else if(tim <= "2008-02-06 13:30:44")       layer.setStyle({"weight": 2.5});
                    else if(tim <= "2008-02-07 13:30:44")       layer.setStyle({"weight": 3.5});
                    else                                        layer.setStyle({"weight": 5});
                    break;
            }
        }
        /////
        /////
        /////


        /////
        ///// support
        /////

        function Unix_timestamp(t){
            var dt = new Date(t);
            var stringDate = dt.toUTCString();
            /*var year = dt.getFullYear();
            var month = dt.getMonth();
            var day = dt.getDay();
            var hour = dt.getHours();
            var minute = dt.getMinutes();
            var seconds = dt.getSeconds();*/

            return stringDate;
        }

        function ColorLuminance(hex, lum) {

            // validate hex string
            hex = String(hex).replace(/[^0-9a-f]/gi, '');
            if (hex.length < 6) {
                hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            }
            lum = lum || 0;

            // convert to decimal and change luminosity
            var rgb = "#", c, i;
            for (i = 0; i < 3; i++) {
                c = parseInt(hex.substr(i*2,2), 16);
                c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
                rgb += ("00"+c).substr(c.length);
            }

            return rgb;
        }

        


